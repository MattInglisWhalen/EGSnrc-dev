<!DOCTYPE html>
<html>
<style>pre {margin: 0;}
</style>
<body>
<pre style="background-color:#AA3E00;"> Overall percentage 54.54%</pre>

<pre>        -:    0:Source:egs_rndm.h</pre>
<pre>        -:    1:/*</pre>
<pre>        -:    2:###############################################################################</pre>
<pre>        -:    3:#</pre>
<pre>        -:    4:#  EGSnrc egs++ random number generators headers</pre>
<pre>        -:    5:#  Copyright (C) 2015 National Research Council Canada</pre>
<pre>        -:    6:#</pre>
<pre>        -:    7:#  This file is part of EGSnrc.</pre>
<pre>        -:    8:#</pre>
<pre>        -:    9:#  EGSnrc is free software: you can redistribute it and/or modify it under</pre>
<pre>        -:   10:#  the terms of the GNU Affero General Public License as published by the</pre>
<pre>        -:   11:#  Free Software Foundation, either version 3 of the License, or (at your</pre>
<pre>        -:   12:#  option) any later version.</pre>
<pre>        -:   13:#</pre>
<pre>        -:   14:#  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY</pre>
<pre>        -:   15:#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</pre>
<pre>        -:   16:#  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for</pre>
<pre>        -:   17:#  more details.</pre>
<pre>        -:   18:#</pre>
<pre>        -:   19:#  You should have received a copy of the GNU Affero General Public License</pre>
<pre>        -:   20:#  along with EGSnrc. If not, see &lthttp://www.gnu.org/licenses/&gt.</pre>
<pre>        -:   21:#</pre>
<pre>        -:   22:###############################################################################</pre>
<pre>        -:   23:#</pre>
<pre>        -:   24:#  Author:          Iwan Kawrakow, 2005</pre>
<pre>        -:   25:#</pre>
<pre>        -:   26:#  Contributors:    Reid Townson</pre>
<pre>        -:   27:#</pre>
<pre>        -:   28:###############################################################################</pre>
<pre>        -:   29:*/</pre>
<pre>        -:   30:</pre>
<pre>        -:   31:</pre>
<pre>        -:   32:/*! \file egs_rndm.h</pre>
<pre>        -:   33: *  \brief EGS_RandomGenerator class header file</pre>
<pre>        -:   34: *  \IK</pre>
<pre>        -:   35: */</pre>
<pre>        -:   36:</pre>
<pre>        -:   37:#ifndef EGS_RANDOM_GENERATOR_</pre>
<pre>        -:   38:#define EGS_RANDOM_GENERATOR_</pre>
<pre>        -:   39:</pre>
<pre>        -:   40:#include "egs_libconfig.h"</pre>
<pre>        -:   41:#include "egs_math.h"</pre>
<pre>        -:   42:#include "egs_functions.h"</pre>
<pre>        -:   43:#include "egs_vector.h"</pre>
<pre>        -:   44:</pre>
<pre>        -:   45:class EGS_Input;</pre>
<pre>        -:   46:</pre>
<pre>        -:   47:/*! \brief Base random number generator class. All random number generators</pre>
<pre>        -:   48: * should be derived from this class.</pre>
<pre>        -:   49: *</pre>
<pre>        -:   50: * \ingroup egspp_main</pre>
<pre>        -:   51: *</pre>
<pre>        -:   52: * A random number generator (RNG) is a central part of every Monte Carlo</pre>
<pre>        -:   53: * simulation. In order to have the possibility of using different</pre>
<pre>        -:   54: * RNGs, the egspp class library defines a RNG as an abstract class.</pre>
<pre>        -:   55: * However, for the sake of efficiency, the main method for drawing</pre>
<pre>        -:   56: * random numbers getUniform() is implemented as an inline function, which</pre>
<pre>        -:   57: * returns the next number in an array of random numbers, possibly after</pre>
<pre>        -:   58: * calling the pure virtual method fillArray() to fill the array with</pre>
<pre>        -:   59: * random numbers. Appart from getUniform(), which returns a random number</pre>
<pre>        -:   60: * uniformely distributed between zero (inclusive) and one (exclusive),</pre>
<pre>        -:   61: * EGS_RandomGenerator implements some frequently needed algorithms such</pre>
<pre>        -:   62: * as picking a random azimuthal angle ( getAzimuth() ) angle and picking</pre>
<pre>        -:   63: * a Gaussian distributed number ( getGaussian() ).</pre>
<pre>        -:   64: *</pre>
<pre>        -:   65: * \todo Should not EGS_RandomGenerator be derived from EGS_Object,</pre>
<pre>        -:   66: * so that dynamically loading RNG DSOs is automatically implemented?</pre>
<pre>        -:   67: */</pre>
<pre>        -:   68:class EGS_EXPORT EGS_RandomGenerator {</pre>
<pre>        -:   69:</pre>
<pre>        -:   70:public:</pre>
<pre>        -:   71:</pre>
<pre>        -:   72:    /*! \brief Construct a RNG that has an array of \a n points to</pre>
<pre>        -:   73:     * hold random numbers.</pre>
<pre>        -:   74:     *</pre>
<pre>        -:   75:     * Memory gets allocated and #rarray points to it. The pointer</pre>
<pre>        -:   76:     * #ip is set to point beyond the array (so that at the next call</pre>
<pre>        -:   77:     * of getUniform() #rarray gets filled via a call to fillArray() ).</pre>
<pre>        -:   78:     */</pre>
<pre style="background-color:#BB0000;">        0:   79:    EGS_RandomGenerator(int n=128);</pre>
<pre>        -:   80:</pre>
<pre>        -:   81:    /*! \brief Copy constructor.</pre>
<pre>        -:   82:     *</pre>
<pre>        -:   83:     * Being able to save the state of a RNG is useful in advanced applications</pre>
<pre>        -:   84:     * such as correlated sampling.</pre>
<pre>        -:   85:     */</pre>
<pre style="background-color:#BB0000;">        0:   86:    EGS_RandomGenerator(const EGS_RandomGenerator &r) : np(0) {</pre>
<pre style="background-color:#BB0000;">        0:   87:        copyBaseState(r);</pre>
<pre>        -:   88:    };</pre>
<pre>        -:   89:</pre>
<pre>        -:   90:    /*! \brief Destructor.</pre>
<pre>        -:   91:     *</pre>
<pre>        -:   92:     * Deallocates the memory pointed to by #rarray.</pre>
<pre>        -:   93:     */</pre>
<pre style="background-color:#BB0000;">        0:   94:    virtual ~EGS_RandomGenerator() {</pre>
<pre style="background-color:#BB0000;">        0:   95:        delete [] rarray;</pre>
<pre>        -:   96:    };</pre>
<pre>        -:   97:</pre>
<pre>        -:   98:    /*! \brief Returns a random number uniformly distributed between</pre>
<pre>        -:   99:     * zero (inclusive) and 1 (exclusive).</pre>
<pre>        -:  100:     *</pre>
<pre>        -:  101:     * Uses the virtual method fillArray() to fill the array #rarray,</pre>
<pre>        -:  102:     * if the pointer #ip points beyond the last element of #rarray.</pre>
<pre>        -:  103:     */</pre>
<pre style="background-color:#00BB00;">  1077632:  104:    inline EGS_Float getUniform() {</pre>
<pre style="background-color:#00BB00;">  1077632:  105:        if (ip &gt= np) {</pre>
<pre style="background-color:#00BB00;">     8421:  106:            fillArray(np,rarray);</pre>
<pre style="background-color:#00BB00;">     8421:  107:            ip = 0;</pre>
<pre>        -:  108:        }</pre>
<pre style="background-color:#00BB00;">  1077632:  109:        return rarray[ip++];</pre>
<pre>        -:  110:    };</pre>
<pre>        -:  111:</pre>
<pre>        -:  112:    /*! \brief Returns the number of random numbers generated so far.</pre>
<pre>        -:  113:     *</pre>
<pre>        -:  114:     * This is useful for simulation diagnostics purposes.</pre>
<pre>        -:  115:     * \sa numbersUsed()</pre>
<pre>        -:  116:     */</pre>
<pre style="background-color:#BB0000;">        0:  117:    EGS_I64 numbersGenerated() const {</pre>
<pre style="background-color:#BB0000;">        0:  118:        return count;</pre>
<pre>        -:  119:    };</pre>
<pre>        -:  120:</pre>
<pre>        -:  121:    /*! \brief Returns the number of random numbers used so far.</pre>
<pre>        -:  122:     *</pre>
<pre>        -:  123:     * This is normally different than numbersGenerated() as some of the</pre>
<pre>        -:  124:     * numbers in the array #rarray may not have been used yet.</pre>
<pre>        -:  125:     */</pre>
<pre style="background-color:#BB0000;">        0:  126:    EGS_I64 numbersUsed() const {</pre>
<pre style="background-color:#BB0000;">        0:  127:        return ip&ltnp ? count - np + ip : count;</pre>
<pre>        -:  128:    };</pre>
<pre>        -:  129:</pre>
<pre>        -:  130:    /*! \brief Sets \a cphi and \a sphi to the cosine and sine of a random</pre>
<pre>        -:  131:     * angle uniformly distributed between 0 and \f$2 \pi \f$.</pre>
<pre>        -:  132:     *</pre>
<pre>        -:  133:     * The default implementation uses a box method since this is faster on</pre>
<pre>        -:  134:     * AMD and Intel CPUs. If the preprocessor macro FAST_SINCOS is defined,</pre>
<pre>        -:  135:     * then an azimuthal angle \f$\phi\f$ is drawn uniformly between</pre>
<pre>        -:  136:     * 0 and \f$2 \pi \f$ and \a cphi and \a sphi are calculated using the</pre>
<pre>        -:  137:     * cosine and sine functions.</pre>
<pre>        -:  138:     */</pre>
<pre style="background-color:#00BB00;">    50000:  139:    inline void getAzimuth(EGS_Float &cphi, EGS_Float &sphi) {</pre>
<pre>        -:  140:#ifndef FAST_SINCOS</pre>
<pre>        -:  141:        EGS_Float xphi,xphi2,yphi,yphi2,rhophi;</pre>
<pre>        -:  142:        do {</pre>
<pre style="background-color:#00BB00;">    63815:  143:            xphi = 2*getUniform() - 1;</pre>
<pre style="background-color:#00BB00;">    63815:  144:            xphi2 = xphi*xphi;</pre>
<pre style="background-color:#00BB00;">    63815:  145:            yphi = getUniform();</pre>
<pre style="background-color:#00BB00;">    63815:  146:            yphi2 = yphi*yphi;</pre>
<pre style="background-color:#00BB00;">    63815:  147:            rhophi = xphi2 + yphi2;</pre>
<pre>        -:  148:        }</pre>
<pre style="background-color:#00BB00;">    63815:  149:        while (rhophi &gt 1);</pre>
<pre style="background-color:#00BB00;">    50000:  150:        cphi = (xphi2 - yphi2)/rhophi;</pre>
<pre style="background-color:#00BB00;">    50000:  151:        sphi = 2*xphi*yphi/rhophi;</pre>
<pre>        -:  152:#else</pre>
<pre>        -:  153:        EGS_Float phi = 2*M_PI*getUniform();</pre>
<pre>        -:  154:        cphi = cos(phi);</pre>
<pre>        -:  155:        sphi = sin(phi);</pre>
<pre>        -:  156:#endif</pre>
<pre>    50000:  157:    };</pre>
<pre>        -:  158:</pre>
<pre>        -:  159:    /*! \brief Returns a Gaussian distributed random number with mean zero</pre>
<pre>        -:  160:     * and standard deviation 1.</pre>
<pre>        -:  161:     */</pre>
<pre style="background-color:#00BB00;">   100000:  162:    inline EGS_Float getGaussian() {</pre>
<pre style="background-color:#00BB00;">   100000:  163:        if (have_x) {</pre>
<pre style="background-color:#00BB00;">    50000:  164:            have_x = false;</pre>
<pre style="background-color:#00BB00;">    50000:  165:            return the_x;</pre>
<pre>        -:  166:        }</pre>
<pre style="background-color:#00BB00;">    50000:  167:        EGS_Float r = sqrt(-2*log(1-getUniform()));</pre>
<pre>        -:  168:        EGS_Float cphi, sphi;</pre>
<pre style="background-color:#00BB00;">    50000:  169:        getAzimuth(cphi,sphi);</pre>
<pre style="background-color:#00BB00;">    50000:  170:        have_x = true;</pre>
<pre style="background-color:#00BB00;">    50000:  171:        the_x = r*sphi;</pre>
<pre style="background-color:#00BB00;">    50000:  172:        return r*cphi;</pre>
<pre>        -:  173:    };</pre>
<pre>        -:  174:</pre>
<pre>        -:  175:    /*! \brief</pre>
<pre>        -:  176:    Get a random unit vector uniformly distributed across the unit sphere.</pre>
<pre>        -:  177:    */</pre>
<pre style="background-color:#00BB00;">   400001:  178:    inline EGS_Vector randomDir(){</pre>
<pre style="background-color:#00BB00;">   400001:  179:        EGS_Float mu = 2 * getUniform() - 1;</pre>
<pre style="background-color:#00BB00;">   400001:  180:        EGS_Float phi = (2 * getUniform() - 1) * M_PI;</pre>
<pre style="background-color:#00BB00;">   400001:  181:        EGS_Float sin_theta = sqrt(1-mu*mu);</pre>
<pre>        -:  182:        // [sin(θ) cos(φ), sin(θ) sin(φ), cos(θ)]</pre>
<pre style="background-color:#00BB00;">   400001:  183:        return {sin_theta * cos(phi), sin_theta * sin(phi), mu};</pre>
<pre>        -:  184:    }</pre>
<pre>        -:  185:</pre>
<pre>        -:  186:    /*! \brief</pre>
<pre>        -:  187:    Get a random unit vector orthogonal to `other`.</pre>
<pre>        -:  188:    */</pre>
<pre style="background-color:#00BB00;">   200001:  189:    inline EGS_Vector randomDirOrthogonalTo(EGS_Vector other){</pre>
<pre>        -:  190</pre>
<pre style="background-color:#00BB00;">   200001:  191:        other.normalize();</pre>
<pre style="background-color:#00BB00;">   200001:  192:        EGS_Vector rand_dir = randomDir();</pre>
<pre style="background-color:#00BB00;">   200001:  193:        EGS_Vector parallel_part = (rand_dir * other) * other;</pre>
<pre style="background-color:#00BB00;">   200001:  194:        EGS_Vector perp_part = rand_dir - parallel_part;</pre>
<pre style="background-color:#00BB00;">   200001:  195:        if(perp_part.length2() &lt 1e-5){</pre>
<pre>        -:  196:            // avoid zero division error</pre>
<pre style="background-color:#00BB00;">        1:  197:            return randomDirOrthogonalTo(other);</pre>
<pre>        -:  198:        }</pre>
<pre style="background-color:#00BB00;">   200000:  199:        return perp_part.normalized();</pre>
<pre>        -:  200:    }</pre>
<pre>        -:  201:</pre>
<pre>        -:  202:    /*! \brief Create a RNG object from the information pointed to by</pre>
<pre>        -:  203:     * \a inp and return a pointer to it.</pre>
<pre>        -:  204:     *</pre>
<pre>        -:  205:     * The input \a inp must either be itself, or it mist have a property</pre>
<pre>        -:  206:     * with key &ltcode&gtrng definition&lt/code&gt, otherwise the return value</pre>
<pre>        -:  207:     * of this function will be \c null. The \a sequence parameter is</pre>
<pre>        -:  208:     * usefull to automatically adjust the initial random number seeds</pre>
<pre>        -:  209:     * in parallel runs.</pre>
<pre>        -:  210:     *</pre>
<pre>        -:  211:     * Note: it is planned to extend this function to be able to create</pre>
<pre>        -:  212:     * RNG objects by dinamically loading RNG dynamic shared objects,</pre>
<pre>        -:  213:     * but this functionality is not there yet. For now, the only RNG</pre>
<pre>        -:  214:     * type available is a ranmar RNG.</pre>
<pre>        -:  215:     */</pre>
<pre style="background-color:#BB0000;">        0:  216:    static EGS_RandomGenerator *createRNG(EGS_Input *inp, int sequence=0);</pre>
<pre>        -:  217:</pre>
<pre>        -:  218:    /*! \brief Returns a pointer to the default egspp RNG.</pre>
<pre>        -:  219:     *</pre>
<pre>        -:  220:     * The default egspp RNG is ranmar. The RNG is initialized with</pre>
<pre>        -:  221:     * by increasing the second ranmar default initial seed by</pre>
<pre>        -:  222:     * \a sequence.</pre>
<pre>        -:  223:     */</pre>
<pre style="background-color:#BB0000;">        0:  224:    static EGS_RandomGenerator *defaultRNG(int sequence=0);</pre>
<pre>        -:  225:</pre>
<pre>        -:  226:    /*! \brief Fill the array of \a n elements pointed to by \a array with</pre>
<pre>        -:  227:     * random numbers.</pre>
<pre>        -:  228:     *</pre>
<pre>        -:  229:     * This pure virtual function must be implemented by derived RNG classes</pre>
<pre>        -:  230:     * to fill the array \a array with \a n random numbers uniformly</pre>
<pre>        -:  231:     * distributed between 0 (inclusive) and 1 (exclusive). The reason for</pre>
<pre>        -:  232:     * having the interval defined to exclude unity is the fact that</pre>
<pre>        -:  233:     * traditionally RNGs used with the EGS system have had this property</pre>
<pre>        -:  234:     * and therefore in many algorithms this behaviour is assumed</pre>
<pre>        -:  235:     * (\em e.g. log(1-r) is used without checking if 1-r is 0).</pre>
<pre>        -:  236:     */</pre>
<pre style="background-color:#BB0000;">        0:  237:    virtual void fillArray(int n, EGS_Float *array) = 0;</pre>
<pre>        -:  238:</pre>
        -:  239:    //@{
<pre>        -:  239:    //@{</pre>
        -:  240:    //! \name state_functions
<pre>        -:  240:    //! \name state_functions</pre>
<pre>        -:  241:    /*! \brief Functions for storing, seting and reseting the state of a RNG</pre>
<pre>        -:  242:     * object.</pre>
<pre>        -:  243:     *</pre>
<pre>        -:  244:     * These functions are useful for being able to perform restarted</pre>
<pre>        -:  245:     * calculations and to combine the result of parallel runs.</pre>
<pre>        -:  246:     * They are used by the default implementations of the</pre>
<pre>        -:  247:     * outputData(), readData(), etc. of the EGS_Application class.</pre>
<pre>        -:  248:     * The base RNG class implementation stores/reads #count, #np, #ip and</pre>
<pre>        -:  249:     * #rarray to the output or input stream \a data.</pre>
<pre>        -:  250:     * Derived RNG classes should should store/read additional data needed</pre>
<pre>        -:  251:     * to set their state to be the same as at the time of executing one</pre>
<pre>        -:  252:     * of these functions by reimplementing the pure virtual functions</pre>
<pre>        -:  253:     * storePrivateState() and setPrivateState().</pre>
<pre>        -:  254:     */</pre>
<pre style="background-color:#BB0000;">        0:  255:    bool storeState(ostream &data);</pre>
<pre style="background-color:#BB0000;">        0:  256:    bool setState(istream &data);</pre>
<pre style="background-color:#BB0000;">        0:  257:    bool addState(istream &data);</pre>
<pre style="background-color:#BB0000;">        0:  258:    void resetCounter() {</pre>
<pre style="background-color:#BB0000;">        0:  259:        count = 0;</pre>
<pre>        -:  260:    };</pre>
        -:  261:    //@}
<pre>        -:  261:    //@}</pre>
<pre>        -:  262:</pre>
<pre>        -:  263:    /*! \brief Get a copy of the RNG */</pre>
<pre style="background-color:#BB0000;">        0:  264:    virtual EGS_RandomGenerator *getCopy() = 0;</pre>
<pre>        -:  265:</pre>
<pre>        -:  266:    /*! \brief Set the state of the RNG from another RNG */</pre>
<pre style="background-color:#BB0000;">        0:  267:    virtual void setState(EGS_RandomGenerator *r) = 0;</pre>
<pre>        -:  268:</pre>
<pre>        -:  269:    /*! \brief Save the RNG state */</pre>
<pre style="background-color:#BB0000;">        0:  270:    virtual void saveState() = 0;</pre>
<pre>        -:  271:</pre>
<pre>        -:  272:    /*! \brief Reset the state to a previously saved state */</pre>
<pre style="background-color:#BB0000;">        0:  273:    virtual void resetState() = 0;</pre>
<pre>        -:  274:</pre>
<pre>        -:  275:    /*! \brief The memory needed to store the rng state */</pre>
<pre style="background-color:#BB0000;">        0:  276:    virtual int  rngSize() const = 0;</pre>
<pre>        -:  277:</pre>
<pre>        -:  278:    /*! \brief Describe this RNG</pre>
<pre>        -:  279:     *</pre>
<pre>        -:  280:     * Derived RNG classes should reimplement this method to output</pre>
<pre>        -:  281:     * some information about the RNG being used in ther simulation.</pre>
<pre>        -:  282:     * This is handy for EGSnrc C++ applications.</pre>
<pre>        -:  283:     */</pre>
<pre style="background-color:#BB0000;">        0:  284:    virtual void describeRNG() const {};</pre>
<pre>        -:  285:</pre>
<pre>        -:  286:protected:</pre>
<pre>        -:  287:</pre>
<pre>        -:  288:    EGS_I64   count;  //!&lt random number generated so far</pre>
<pre>        -:  289:    int       np;     //!&lt size of the array rarray</pre>
<pre>        -:  290:    int       ip;     //!&lt pointer to the next rarray element in the sequence</pre>
<pre>        -:  291:    EGS_Float *rarray;//!&lt array with random numbers of size np.</pre>
<pre>        -:  292:</pre>
<pre>        -:  293:    /*! \brief Store the state of the RNG to the output stream \a data.</pre>
<pre>        -:  294:     *</pre>
<pre>        -:  295:     * Derived RNG classes must implement this function to store as much data</pre>
<pre>        -:  296:     * as needed to the output stream \a data so that a RNG</pre>
<pre>        -:  297:     * object can be set to exactly the same using these data by</pre>
<pre>        -:  298:     * invoking setPrivateState().</pre>
<pre>        -:  299:     *</pre>
<pre>        -:  300:     * \sa storeState(), setState().</pre>
<pre>        -:  301:     */</pre>
<pre style="background-color:#BB0000;">        0:  302:    virtual bool storePrivateState(ostream &data) =  0;</pre>
<pre>        -:  303:</pre>
<pre>        -:  304:    /*! \brief Set the state of the RNG object from the data in the input</pre>
<pre>        -:  305:     * stream \a data.</pre>
<pre>        -:  306:     *</pre>
<pre>        -:  307:     * This method must be implemented in derived RNG classes. It should read</pre>
<pre>        -:  308:     * the same data as stored by storePrivateState() in the same order from</pre>
<pre>        -:  309:     * the input stream \a data.</pre>
<pre>        -:  310:     */</pre>
<pre style="background-color:#BB0000;">        0:  311:    virtual bool setPrivateState(istream &data) =  0;</pre>
<pre>        -:  312:</pre>
<pre style="background-color:#BB0000;">        0:  313:    void copyBaseState(const EGS_RandomGenerator &r);</pre>
<pre>        -:  314:</pre>
<pre style="background-color:#BB0000;">        0:  315:    void allocate(int n);</pre>
<pre>        -:  316:</pre>
<pre>        -:  317:    /*! \brief The memory needed to store the base state */</pre>
<pre style="background-color:#BB0000;">        0:  318:    int  baseSize() const {</pre>
<pre style="background-color:#BB0000;">        0:  319:        return 2*sizeof(EGS_I32) + sizeof(EGS_I64) + sizeof(bool) +</pre>
<pre style="background-color:#BB0000;">        0:  320:               sizeof(EGS_Float) + np*sizeof(EGS_Float);</pre>
<pre>        -:  321:    };</pre>
<pre>        -:  322:</pre>
<pre>        -:  323:</pre>
<pre>        -:  324:private:</pre>
<pre>        -:  325:</pre>
<pre>        -:  326:    bool      have_x; //!&lt used for sampling Gaussian random numbers</pre>
<pre>        -:  327:    EGS_Float the_x;  //!&lt used for sampling Gaussian random numbers</pre>
<pre>        -:  328:</pre>
<pre>        -:  329:};</pre>
<pre>        -:  330:</pre>
<pre>        -:  331:#endif</pre>

</body></html>

<!DOCTYPE html>
<html>
<style>pre {margin: 0;}
</style>
<body>
<pre style="background-color:#AA3E00;"> Overall percentage 56.75%</pre>

<pre>        -:    0:Source:egs_vector.h</pre>
<pre>        -:    1:/*</pre>
<pre>        -:    2:###############################################################################</pre>
<pre>        -:    3:#</pre>
<pre>        -:    4:#  EGSnrc egs++ vector headers</pre>
<pre>        -:    5:#  Copyright (C) 2015 National Research Council Canada</pre>
<pre>        -:    6:#</pre>
<pre>        -:    7:#  This file is part of EGSnrc.</pre>
<pre>        -:    8:#</pre>
<pre>        -:    9:#  EGSnrc is free software: you can redistribute it and/or modify it under</pre>
<pre>        -:   10:#  the terms of the GNU Affero General Public License as published by the</pre>
<pre>        -:   11:#  Free Software Foundation, either version 3 of the License, or (at your</pre>
<pre>        -:   12:#  option) any later version.</pre>
<pre>        -:   13:#</pre>
<pre>        -:   14:#  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY</pre>
<pre>        -:   15:#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</pre>
<pre>        -:   16:#  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for</pre>
<pre>        -:   17:#  more details.</pre>
<pre>        -:   18:#</pre>
<pre>        -:   19:#  You should have received a copy of the GNU Affero General Public License</pre>
<pre>        -:   20:#  along with EGSnrc. If not, see &lthttp://www.gnu.org/licenses/&gt.</pre>
<pre>        -:   21:#</pre>
<pre>        -:   22:###############################################################################</pre>
<pre>        -:   23:#</pre>
<pre>        -:   24:#  Author:          Iwan Kawrakow, 2005</pre>
<pre>        -:   25:#</pre>
<pre>        -:   26:#  Contributors:    Manuel Stoeckl</pre>
<pre>        -:   27:#                   Reid Townson</pre>
<pre>        -:   28:#                   Matthew Inglis-Whalen</pre>
<pre>        -:   29:#</pre>
<pre>        -:   30:###############################################################################</pre>
<pre>        -:   31:*/</pre>
<pre>        -:   32:</pre>
<pre>        -:   33:</pre>
<pre>        -:   34:/*! \file egs_vector.h</pre>
<pre>        -:   35: *  \brief EGS_Vector methods for the manipulation of 3D vectors in</pre>
<pre>        -:   36: *  cartesian coordinates.</pre>
<pre>        -:   37: *  \IK</pre>
<pre>        -:   38: */</pre>
<pre>        -:   39:</pre>
<pre>        -:   40:#ifndef EGS_VECTOR_</pre>
<pre>        -:   41:#define EGS_VECTOR_</pre>
<pre>        -:   42:</pre>
<pre>        -:   43:#include &ltstring&gt</pre>
<pre>        -:   44:</pre>
<pre>        -:   45:#include "egs_functions.h"</pre>
<pre>        -:   46:#include "egs_libconfig.h"</pre>
<pre>        -:   47:</pre>
<pre>        -:   48:#include "egs_math.h"</pre>
<pre>        -:   49:</pre>
<pre>        -:   50:/*! \brief A class representing 3D vectors.</pre>
<pre>        -:   51:</pre>
<pre>        -:   52:  \ingroup egspp_main</pre>
<pre>        -:   53:</pre>
<pre>        -:   54:  The EGS_Vector class is used throughout egs++ for representing 3D</pre>
<pre>        -:   55:  vectors in cartesian coordinates</pre>
<pre>        -:   56:  (\em e.g. particle positions and directions). It provides</pre>
<pre>        -:   57:  various convenience methods for vector additions, subtractions,</pre>
<pre>        -:   58:  multiplications, etc.</pre>
<pre>        -:   59:*/</pre>
<pre>        -:   60:class EGS_EXPORT EGS_Vector {</pre>
<pre>        -:   61:</pre>
<pre>        -:   62:public:</pre>
<pre>        -:   63:</pre>
        -:   64[m[K:    /// The x component of the vector
<pre>        -:   64:    /// The x component of the vector</pre>
<pre>        -:   65:    EGS_Float x;</pre>
        -:   66[m[K:    /// The y component of the vector
<pre>        -:   66:    /// The y component of the vector</pre>
<pre>        -:   67:    EGS_Float y;</pre>
        -:   68[m[K:    /// The z component of the vector
<pre>        -:   68:    /// The z component of the vector</pre>
<pre>        -:   69:    EGS_Float z;</pre>
<pre>        -:   70:</pre>
<pre>        -:   71:    /*! \brief</pre>
<pre>        -:   72:      Component constructor; sets individual components x, y, z.</pre>
<pre>        -:   73:    */</pre>
<pre style="background-color:#00BB00;"> 1000059*:   74:    EGS_Vector(EGS_Float xx, EGS_Float yy, EGS_Float zz) : x(xx), y(yy), z(zz) {}</pre>
<pre>------------------</pre>
<pre>_ZN10EGS_VectorC2Eddd:</pre>
<pre style="background-color:#00BB00;">  1000059:   74:    EGS_Vector(EGS_Float xx, EGS_Float yy, EGS_Float zz) : x(xx), y(yy), z(zz) {}</pre>
<pre>------------------</pre>
<pre>_ZN10EGS_VectorC2Eddd:</pre>
<pre style="background-color:#00BB00;">    #####:   74:    EGS_Vector(EGS_Float xx, EGS_Float yy, EGS_Float zz) : x(xx), y(yy), z(zz) {}</pre>
<pre>------------------</pre>
<pre>        -:   75:</pre>
<pre>        -:   76:    /*! \brief</pre>
<pre>        -:   77:      Copy constructor; copies x, y, z components of \a v.</pre>
<pre>        -:   78:    */</pre>
<pre style="background-color:#00BB00;">  200003*:   79:    EGS_Vector(const EGS_Vector &v) : x(v.x), y(v.y), z(v.z) {}</pre>
<pre>------------------</pre>
<pre>_ZN10EGS_VectorC2ERKS_:</pre>
<pre style="background-color:#00BB00;">   200003:   79:    EGS_Vector(const EGS_Vector &v) : x(v.x), y(v.y), z(v.z) {}</pre>
<pre>------------------</pre>
<pre>_ZN10EGS_VectorC2ERKS_:</pre>
<pre style="background-color:#00BB00;">    #####:   79:    EGS_Vector(const EGS_Vector &v) : x(v.x), y(v.y), z(v.z) {}</pre>
<pre>------------------</pre>
<pre>        -:   80:</pre>
<pre>        -:   81:    /*! \brief</pre>
<pre>        -:   82:      Default constructor; all components set to zero.</pre>
<pre>        -:   83:    */</pre>
<pre style="background-color:#00BB00;">        1:   84:    EGS_Vector() : x(0), y(0), z(0) {}</pre>
<pre>        -:   85:</pre>
<pre>        -:   86:    /*! \brief</pre>
<pre>        -:   87:      Assignment operator; applies componentwise assignment for x, y, z from the components of \a v.</pre>
<pre>        -:   88:    */</pre>
<pre style="background-color:#BB0000;">        0:   89:    EGS_Vector &operator=(const EGS_Vector &v) {</pre>
<pre style="background-color:#BB0000;">        0:   90:        x = v.x;</pre>
<pre style="background-color:#BB0000;">        0:   91:        y = v.y;</pre>
<pre style="background-color:#BB0000;">        0:   92:        z = v.z;</pre>
<pre style="background-color:#BB0000;">        0:   93:        return *this;</pre>
<pre>        -:   94:    }</pre>
<pre>        -:   95:</pre>
<pre>        -:   96:    /*! \brief</pre>
<pre>        -:   97:      Indexed access; for when you want to access the components by index {0, 1, 2} rather than by its name</pre>
<pre>        -:   98:    */</pre>
<pre style="background-color:#00BB00;">        3:   99:    EGS_Float operator[](size_t idx) const {</pre>
<pre>        -:  100:        // branchless implementation with no error handling</pre>
<pre style="background-color:#00BB00;">        3:  101:        return 0.5*(idx-1)*(idx-2)*x - idx*(idx-2)*y + 0.5*idx*(idx-1)*z;</pre>
<pre>        -:  102:    }</pre>
<pre>        -:  103:</pre>
<pre>        -:  104:    /*! \brief</pre>
<pre>        -:  105:      Indexed access; for when you want to access the components by index {0, 1, 2} rather than by its name.</pre>
<pre>        -:  106:    */</pre>
<pre style="background-color:#BB0000;">        0:  107:    EGS_Float at(size_t idx) const {</pre>
<pre style="background-color:#BB0000;">        0:  108:        // This is simply a named version of operator[], for e.g. more convenient usage with pointers</pre>
<pre style="background-color:#BB0000;">        0:  109:        // I.e. 5 * v-&gtat(0) is easier to read than 5 * (*v)[0]</pre>
<pre style="background-color:#BB0000;">        0:  110:        return 0.5*(idx-1)*(idx-2)*x - idx*(idx-2)*y + 0.5*idx*(idx-1)*z;</pre>
<pre>        -:  111:    }</pre>
<pre>        -:  112:</pre>
<pre>        -:  113:    /*! \brief</pre>
<pre>        -:  114:      Compares the vector to the zero vector, with the default |v|^2</pre>
<pre>        -:  115:      tolerance of 1e-10 configurable with setTolerance()</pre>
<pre>        -:  116:    */</pre>
<pre style="background-color:#00BB00;">       21:  117:    bool isZero() const {</pre>
<pre style="background-color:#00BB00;">       21:  118:        return length2() &lt EGS_Vector:tolerance;</pre>
<pre>        -:  119:    }</pre>
<pre>        -:  120:    /*! \brief</pre>
<pre>        -:  121:      Comparison operator; returns true when all components</pre>
<pre>        -:  122:      of the two vectors are equal (up to the default tolerance of 1e-10)</pre>
<pre>        -:  123:    */</pre>
<pre style="background-color:#00BB00;">       18:  124:    bool operator==(const EGS_Vector &v) const {</pre>
<pre style="background-color:#00BB00;">       18:  125:        return operator-(v).isZero();</pre>
<pre>        -:  126:    }</pre>
<pre>        -:  127:    /*! \brief</pre>
<pre>        -:  128:      Comparison operator; returns true when all components</pre>
<pre>        -:  129:      of the two vectors are equal (relative to the default tolerance of 1e-10)</pre>
<pre>        -:  130:    */</pre>
<pre style="background-color:#00BB00;">        2:  131:    bool operator!=(const EGS_Vector &v) const {</pre>
<pre style="background-color:#00BB00;">        2:  132:        return !operator==(v);</pre>
<pre>        -:  133:    }</pre>
<pre>        -:  134:</pre>
<pre>        -:  135:    /*! \brief</pre>
<pre>        -:  136:      Addition of an EGS_Vector with another EGS_Vector \a v</pre>
<pre>        -:  137:    */</pre>
<pre style="background-color:#00BB00;">        3:  138:    EGS_Vector operator+(const EGS_Vector &v) const {</pre>
<pre style="background-color:#00BB00;">        3:  139:        return EGS_Vector(x+v.x, y+v.y, z+v.z);</pre>
<pre>        -:  140:    }</pre>
<pre>        -:  141:    /*! \brief</pre>
<pre>        -:  142:      In-place addition of an EGS_Vector with another EGS_Vector \a v</pre>
<pre>        -:  143:    */</pre>
<pre style="background-color:#00BB00;">        1:  144:    EGS_Vector &operator+=(const EGS_Vector &v) {</pre>
<pre style="background-color:#00BB00;">        1:  145:        x += v.x;</pre>
<pre style="background-color:#00BB00;">        1:  146:        y += v.y;</pre>
<pre style="background-color:#00BB00;">        1:  147:        z += v.z;</pre>
<pre style="background-color:#00BB00;">        1:  148:        return *this;</pre>
<pre>        -:  149:    }</pre>
<pre>        -:  150:</pre>
<pre>        -:  151:    /*! \brief</pre>
<pre>        -:  152:      Negation operator; flips the sign of each component in the vector</pre>
<pre>        -:  153:    */</pre>
<pre style="background-color:#00BB00;">        1:  154:    EGS_Vector operator-() const {</pre>
<pre style="background-color:#00BB00;">        1:  155:        return EGS_Vector(-x, -y, -z);</pre>
<pre>        -:  156:    }</pre>
<pre>        -:  157:    /*! \brief</pre>
<pre>        -:  158:      Subtraction of an EGS_Vector by another EGS_Vector \a v</pre>
<pre>        -:  159:    */</pre>
<pre>  200021*:  160:    EGS_Vector operator-(const EGS_Vector &v) const {</pre>
<pre>  200021*:  161:        return EGS_Vector(x-v.x, y-v.y, z-v.z);</pre>
<pre>        -:  162:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_VectormiERKS_:</pre>
<pre style="background-color:#00BB00;">   200021:  160:    EGS_Vector operator-(const EGS_Vector &v) const {</pre>
<pre style="background-color:#00BB00;">   200021:  161:        return EGS_Vector(x-v.x, y-v.y, z-v.z);</pre>
<pre>        -:  162:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_VectormiERKS_:</pre>
<pre style="background-color:#BB0000;">    #####:  160:    EGS_Vector operator-(const EGS_Vector &v) const {</pre>
<pre style="background-color:#BB0000;">    #####:  161:        return EGS_Vector(x-v.x, y-v.y, z-v.z);</pre>
<pre>        -:  162:    }</pre>
<pre>------------------</pre>
<pre>        -:  163:    /*! \brief</pre>
<pre>        -:  164:      In-place subtraction of an EGS_Vector by another EGS_Vector \a  v</pre>
<pre>        -:  165:    */</pre>
<pre style="background-color:#00BB00;">        1:  166:    EGS_Vector &operator-=(const EGS_Vector &v) {</pre>
<pre style="background-color:#00BB00;">        1:  167:        x -= v.x;</pre>
<pre style="background-color:#00BB00;">        1:  168:        y -= v.y;</pre>
<pre style="background-color:#00BB00;">        1:  169:        z -= v.z;</pre>
<pre style="background-color:#00BB00;">        1:  170:        return *this;</pre>
<pre>        -:  171:    }</pre>
<pre>        -:  172:</pre>
<pre>        -:  173:    /*! \brief</pre>
<pre>        -:  174:      Multiplication of an EGS_Vector by a float \a f on the right</pre>
<pre>        -:  175:    */</pre>
<pre>  200003*:  176:    EGS_Vector operator*(const EGS_Float f) const {</pre>
<pre>  200003*:  177:        return EGS_Vector(x*f, y*f, z*f);</pre>
<pre>        -:  178:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_VectormlEd:</pre>
<pre style="background-color:#00BB00;">   200003:  176:    EGS_Vector operator*(const EGS_Float f) const {</pre>
<pre style="background-color:#00BB00;">   200003:  177:        return EGS_Vector(x*f, y*f, z*f);</pre>
<pre>        -:  178:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_VectormlEd:</pre>
<pre style="background-color:#BB0000;">    #####:  176:    EGS_Vector operator*(const EGS_Float f) const {</pre>
<pre style="background-color:#BB0000;">    #####:  177:        return EGS_Vector(x*f, y*f, z*f);</pre>
<pre>        -:  178:    }</pre>
<pre>------------------</pre>
<pre>        -:  179:    /*! \brief</pre>
<pre>        -:  180:      In-place multiplication of an EGS_Vector by a float \a f</pre>
<pre>        -:  181:    */</pre>
<pre style="background-color:#00BB00;">        1:  182:    EGS_Vector &operator*=(const EGS_Float f) {</pre>
<pre style="background-color:#00BB00;">        1:  183:        x *= f;</pre>
<pre style="background-color:#00BB00;">        1:  184:        y *= f;</pre>
<pre style="background-color:#00BB00;">        1:  185:        z *= f;</pre>
<pre style="background-color:#00BB00;">        1:  186:        return *this;</pre>
<pre>        -:  187:    }</pre>
<pre>        -:  188:    /*! \brief</pre>
<pre>        -:  189:      Multiplication of an EGS_Vector by a float \a f on the left</pre>
<pre>        -:  190:    */</pre>
<pre>  200002*:  191:    friend EGS_Vector operator*(EGS_Float f, const EGS_Vector &v) {</pre>
<pre>  200002*:  192:        return v*f;</pre>
<pre>        -:  193:    }</pre>
<pre>------------------</pre>
<pre>_ZmldRK10EGS_Vector:</pre>
<pre style="background-color:#00BB00;">   200002:  191:    friend EGS_Vector operator*(EGS_Float f, const EGS_Vector &v) {</pre>
<pre style="background-color:#00BB00;">   200002:  192:        return v*f;</pre>
<pre>        -:  193:    }</pre>
<pre>------------------</pre>
<pre>_ZmldRK10EGS_Vector:</pre>
<pre style="background-color:#BB0000;">    #####:  191:    friend EGS_Vector operator*(EGS_Float f, const EGS_Vector &v) {</pre>
<pre style="background-color:#BB0000;">    #####:  192:        return v*f;</pre>
<pre>        -:  193:    }</pre>
<pre>------------------</pre>
<pre>        -:  194:</pre>
<pre>        -:  195:    /*! \brief</pre>
<pre>        -:  196:      Division of an EGS_Vector by a float \a f</pre>
<pre>        -:  197:    */</pre>
<pre style="background-color:#00BB00;">        3:  198:    EGS_Vector operator/(EGS_Float f) const {</pre>
<pre style="background-color:#00BB00;">        3:  199:        return EGS_Vector(x/f, y/f, z/f);</pre>
<pre>        -:  200:    }</pre>
<pre>        -:  201:    /*! \brief</pre>
<pre>        -:  202:      In-place division of an EGS_Vector by a float \a f</pre>
<pre>        -:  203:    */</pre>
<pre style="background-color:#00BB00;">        1:  204:    EGS_Vector &operator/=(EGS_Float f) {</pre>
<pre style="background-color:#00BB00;">        1:  205:        x /= f;</pre>
<pre style="background-color:#00BB00;">        1:  206:        y /= f;</pre>
<pre style="background-color:#00BB00;">        1:  207:        z /= f;</pre>
<pre style="background-color:#00BB00;">        1:  208:        return *this;</pre>
<pre>        -:  209:    }</pre>
<pre>        -:  210:</pre>
<pre>        -:  211:    /*! \brief</pre>
<pre>        -:  212:      Returns the inner product (dot product) of an EGS_Vector with another EGS_Vector \a v</pre>
<pre>        -:  213:    */</pre>
<pre>  200001*:  214:    EGS_Float dot(const EGS_Vector &v) const {</pre>
<pre>  200001*:  215:        return x*v.x + y*v.y + z*v.z;</pre>
<pre>        -:  216:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector3dotERKS_:</pre>
<pre style="background-color:#00BB00;">   200001:  214:    EGS_Float dot(const EGS_Vector &v) const {</pre>
<pre style="background-color:#00BB00;">   200001:  215:        return x*v.x + y*v.y + z*v.z;</pre>
<pre>        -:  216:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector3dotERKS_:</pre>
<pre style="background-color:#BB0000;">    #####:  214:    EGS_Float dot(const EGS_Vector &v) const {</pre>
<pre style="background-color:#BB0000;">    #####:  215:        return x*v.x + y*v.y + z*v.z;</pre>
<pre>        -:  216:    }</pre>
<pre>------------------</pre>
<pre>        -:  217:    /*! \brief</pre>
<pre>        -:  218:      Returns the inner product (dot product) of an EGS_Vector with another EGS_Vector \a v.</pre>
<pre>        -:  219:    */</pre>
<pre>  200002*:  220:    EGS_Float operator*(const EGS_Vector &v) const {</pre>
<pre>        -:  221:        // Syntactic sugar for the `dot` function</pre>
<pre>  200002*:  222:        return x*v.x + y*v.y + z*v.z;</pre>
<pre>        -:  223:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_VectormlERKS_:</pre>
<pre style="background-color:#00BB00;">   200002:  220:    EGS_Float operator*(const EGS_Vector &v) const {</pre>
<pre>        -:  221:        // Syntactic sugar for the `dot` function</pre>
<pre style="background-color:#00BB00;">   200002:  222:        return x*v.x + y*v.y + z*v.z;</pre>
<pre>        -:  223:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_VectormlERKS_:</pre>
<pre style="background-color:#BB0000;">    #####:  220:    EGS_Float operator*(const EGS_Vector &v) const {</pre>
<pre>        -:  221:        // Syntactic sugar for the `dot` function</pre>
<pre style="background-color:#BB0000;">    #####:  222:        return x*v.x + y*v.y + z*v.z;</pre>
<pre>        -:  223:    }</pre>
<pre>------------------</pre>
<pre>        -:  224:</pre>
<pre>        -:  225:    /*! \brief</pre>
<pre>        -:  226:      Returns the vector product (cross product, symbol \times), of this EGS_Vector and another EGS_Vector \a v</pre>
<pre>        -:  227:    */</pre>
<pre style="background-color:#00BB00;">        1:  228:    EGS_Vector times(const EGS_Vector &v) const {</pre>
<pre style="background-color:#00BB00;">        1:  229:        return EGS_Vector(y*v.z - z*v.y, z*v.x - x*v.z, x*v.y - y*v.x);</pre>
<pre>        -:  230:    }</pre>
<pre>        -:  231:    /*! \brief</pre>
<pre>        -:  232:      Returns the vector product (cross product), of this EGS_Vector and another EGS_Vector \a v.</pre>
<pre>        -:  233:    */</pre>
<pre style="background-color:#00BB00;">        1:  234:    EGS_Vector operator%(const EGS_Vector &v) const {</pre>
<pre>        -:  235:        // Syntactic sugar for the `times` function</pre>
<pre style="background-color:#00BB00;">        1:  236:        return EGS_Vector(y*v.z - z*v.y, z*v.x - x*v.z, x*v.y - y*v.x);</pre>
<pre>        -:  237:    }</pre>
<pre>        -:  238:</pre>
<pre>        -:  239:    /*! \brief</pre>
<pre>        -:  240:      Componentwise multiplication of an EGS_Vector by another EGS_Vector \a s.</pre>
<pre>        -:  241:</pre>
<pre>        -:  242:      Equivalent to multiplying by a 3x3 diagonal matrix whose entries are the components of \a s</pre>
<pre>        -:  243:    */</pre>
<pre style="background-color:#BB0000;">        0:  244:    EGS_Vector getScaled(const EGS_Vector &s) const {</pre>
<pre style="background-color:#BB0000;">        0:  245:        return EGS_Vector(x*s.x, y*s.y, z*s.z);</pre>
<pre>        -:  246:    }</pre>
<pre>        -:  247:    /*! \brief</pre>
<pre>        -:  248:      In-place componentwise multiplication of an EGS_Vector by another EGS_Vector \a s.</pre>
<pre>        -:  249:</pre>
<pre>        -:  250:      Equivalent to multiplying by a 3x3 diagonal matrix whose entries are the components of \a s</pre>
<pre>        -:  251:    */</pre>
<pre style="background-color:#BB0000;">        0:  252:    void scale(const EGS_Vector &s) {</pre>
<pre style="background-color:#BB0000;">        0:  253:        x *= s.x;</pre>
<pre style="background-color:#BB0000;">        0:  254:        y *= s.y;</pre>
<pre style="background-color:#BB0000;">        0:  255:        z *= s.z;</pre>
<pre>        -:  256:    }</pre>
<pre>        -:  257:</pre>
<pre>        -:  258:    /*! \brief</pre>
<pre>        -:  259:      The L2 norm of the EGS_Vector</pre>
<pre>        -:  260:    */</pre>
<pre>  400004*:  261:    EGS_Float length() const {</pre>
<pre>  400004*:  262:        return sqrt(x*x+y*y+z*z);</pre>
<pre>        -:  263:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector6lengthEv:</pre>
<pre style="background-color:#00BB00;">   400004:  261:    EGS_Float length() const {</pre>
<pre style="background-color:#00BB00;">   400004:  262:        return sqrt(x*x+y*y+z*z);</pre>
<pre>        -:  263:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector6lengthEv:</pre>
<pre style="background-color:#BB0000;">    #####:  261:    EGS_Float length() const {</pre>
<pre style="background-color:#BB0000;">    #####:  262:        return sqrt(x*x+y*y+z*z);</pre>
<pre>        -:  263:    }</pre>
<pre>------------------</pre>
<pre>        -:  264:    /*! \brief</pre>
<pre>        -:  265:      The squared length of the EGS_Vector</pre>
<pre>        -:  266:    */</pre>
<pre>  200023*:  267:    EGS_Float length2() const {</pre>
<pre>  200023*:  268:        return x*x+y*y+z*z;</pre>
<pre>        -:  269:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector7length2Ev:</pre>
<pre style="background-color:#00BB00;">   200023:  267:    EGS_Float length2() const {</pre>
<pre style="background-color:#00BB00;">   200023:  268:        return x*x+y*y+z*z;</pre>
<pre>        -:  269:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector7length2Ev:</pre>
<pre style="background-color:#BB0000;">    #####:  267:    EGS_Float length2() const {</pre>
<pre style="background-color:#BB0000;">    #####:  268:        return x*x+y*y+z*z;</pre>
<pre>        -:  269:    }</pre>
<pre>------------------</pre>
<pre>        -:  270:</pre>
<pre>        -:  271:    /*! \brief</pre>
<pre>        -:  272:      Returns a normalized copy of the EGS_Vector</pre>
<pre>        -:  273:    */</pre>
<pre>  200001*:  274:    EGS_Vector normalized() const {</pre>
<pre>        -:  275:        // In c++17 this should come with the [[nodiscard]] attribute</pre>
<pre>  200001*:  276:        EGS_Float norm = 1./length();</pre>
<pre>  200001*:  277:        return EGS_Vector(x*norm, y*norm, z*norm);</pre>
<pre>        -:  278:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector10normalizedEv:</pre>
<pre style="background-color:#00BB00;">   200001:  274:    EGS_Vector normalized() const {</pre>
<pre>        -:  275:        // In c++17 this should come with the [[nodiscard]] attribute</pre>
<pre style="background-color:#00BB00;">   200001:  276:        EGS_Float norm = 1./length();</pre>
<pre style="background-color:#00BB00;">   200001:  277:        return EGS_Vector(x*norm, y*norm, z*norm);</pre>
<pre>        -:  278:    }</pre>
<pre>------------------</pre>
<pre>_ZNK10EGS_Vector10normalizedEv:</pre>
<pre style="background-color:#BB0000;">    #####:  274:    EGS_Vector normalized() const {</pre>
<pre>        -:  275:        // In c++17 this should come with the [[nodiscard]] attribute</pre>
<pre style="background-color:#BB0000;">    #####:  276:        EGS_Float norm = 1./length();</pre>
<pre style="background-color:#BB0000;">    #####:  277:        return EGS_Vector(x*norm, y*norm, z*norm);</pre>
<pre>        -:  278:    }</pre>
<pre>------------------</pre>
<pre>        -:  279:    /*! \brief</pre>
<pre>        -:  280:      In-place normalization of the EGS_Vector</pre>
<pre>        -:  281:    */</pre>
<pre>  200002*:  282:    void normalize() {</pre>
<pre>        -:  283:        // equivalent to v /= v.length();</pre>
<pre>  200002*:  284:        EGS_Float tmp = 1./length();</pre>
<pre>  200002*:  285:        x *= tmp;</pre>
<pre>  200002*:  286:        y *= tmp;</pre>
<pre>  200002*:  287:        z *= tmp;</pre>
<pre>  200002*:  288:    }</pre>
<pre>------------------</pre>
<pre>_ZN10EGS_Vector9normalizeEv:</pre>
<pre style="background-color:#00BB00;">   200002:  282:    void normalize() {</pre>
<pre>        -:  283:        // equivalent to v /= v.length();</pre>
<pre style="background-color:#00BB00;">   200002:  284:        EGS_Float tmp = 1./length();</pre>
<pre style="background-color:#00BB00;">   200002:  285:        x *= tmp;</pre>
<pre style="background-color:#00BB00;">   200002:  286:        y *= tmp;</pre>
<pre style="background-color:#00BB00;">   200002:  287:        z *= tmp;</pre>
<pre>   200002:  288:    }</pre>
<pre>------------------</pre>
<pre>_ZN10EGS_Vector9normalizeEv:</pre>
<pre style="background-color:#BB0000;">    #####:  282:    void normalize() {</pre>
<pre>        -:  283:        // equivalent to v /= v.length();</pre>
<pre style="background-color:#BB0000;">    #####:  284:        EGS_Float tmp = 1./length();</pre>
<pre style="background-color:#BB0000;">    #####:  285:        x *= tmp;</pre>
<pre style="background-color:#BB0000;">    #####:  286:        y *= tmp;</pre>
<pre style="background-color:#BB0000;">    #####:  287:        z *= tmp;</pre>
<pre>    #####:  288:    }</pre>
<pre>------------------</pre>
<pre>        -:  289:</pre>
<pre>        -:  290:    /*! \brief</pre>
<pre>        -:  291:      In-place rotation of an EGS_Vector that is assumed to be already normalized.</pre>
<pre>        -:  292:      The vector `r'` after rotation is the linear combination</pre>
<pre>        -:  293:</pre>
<pre>        -:  294:      `r' = cθ r + sθ r⟂`</pre>
<pre>        -:  295:</pre>
<pre>        -:  296:      where `r` is the original vector to which `r⟂` is orthogonal.</pre>
<pre>        -:  297:    */</pre>
<pre>        1:  298:    void rotate(EGS_Float cos_t, EGS_Float sin_t,</pre>
<pre>        -:  299:                EGS_Float c_phi, EGS_Float s_phi) {</pre>
<pre>        -:  300</pre>
<pre>        -:  301:        // this is an old function so it can't be renamed</pre>
<pre>        -:  302</pre>
<pre style="background-color:#00BB00;">        1:  303:        EGS_Float sin_z = x*x + y*y;</pre>
<pre style="background-color:#00BB00;">        1:  304:        if (sin_z &gt epsilon) {</pre>
<pre style="background-color:#BB0000;">    #####:  305:            sin_z = sqrt(sin_z);</pre>
<pre style="background-color:#BB0000;">    #####:  306:            EGS_Float temp = sin_t/sin_z;</pre>
<pre style="background-color:#BB0000;">    #####:  307:            EGS_Float temp_phi = z*c_phi;</pre>
<pre style="background-color:#BB0000;">    #####:  308:            x = x*cos_t + temp*(temp_phi*x - y*s_phi);</pre>
<pre style="background-color:#BB0000;">    #####:  309:            y = y*cos_t + temp*(temp_phi*y + x*s_phi);</pre>
<pre style="background-color:#BB0000;">    #####:  310:            z = z*cos_t - sin_z*sin_t*c_phi;</pre>
<pre>        -:  311:        }</pre>
<pre>        -:  312:        else {</pre>
<pre style="background-color:#00BB00;">        1:  313:            x = sin_t*c_phi;</pre>
<pre style="background-color:#00BB00;">        1:  314:            y = sin_t*s_phi;</pre>
<pre style="background-color:#00BB00;">        1:  315:            z *= cos_t;</pre>
<pre>        -:  316:        }</pre>
<pre>        1:  317:    }</pre>
<pre>        -:  318:</pre>
<pre>        -:  319:    /*! \brief</pre>
<pre>        -:  320:      In-place rotation of an EGS_Vector with arbitrary (dimensionful) length.</pre>
<pre>        -:  321:      The vector `r'` after rotation is the linear combination</pre>
<pre>        -:  322:</pre>
<pre>        -:  323:      `r' = cθ r + sθ r⟂`</pre>
<pre>        -:  324:</pre>
<pre>        -:  325:      where `r` is the original vector to which `r⟂` is orthogonal, and these both share the same length.</pre>
<pre>        -:  326:    */</pre>
<pre>        -:  327:    void rotateDimensionful(</pre>
<pre>        -:  328:        EGS_Float cos_t,</pre>
<pre>        -:  329:        EGS_Float sin_t,</pre>
<pre>        -:  330:        EGS_Float c_phi,</pre>
<pre style="background-color:#BB0000;">        0:  331:        EGS_Float s_phi) {</pre>
<pre style="background-color:#BB0000;">        0:  332</pre>
<pre style="background-color:#BB0000;">        0:  333:        // follows the same algorithm as rotate() but accounting for arbitrary lengths</pre>
<pre style="background-color:#BB0000;">        0:  334</pre>
<pre style="background-color:#BB0000;">        0:  335:        EGS_Float rho_sqr = x*x + y*y;</pre>
<pre style="background-color:#BB0000;">        0:  336:        EGS_Float L_sqr = rho_sqr + z*z;</pre>
<pre style="background-color:#BB0000;">        0:  337</pre>
<pre style="background-color:#BB0000;">        0:  338:        if (rho_sqr &gt epsilon) {</pre>
<pre style="background-color:#BB0000;">        0:  339</pre>
<pre style="background-color:#BB0000;">        0:  340:            EGS_Float rho = sqrt(rho_sqr);</pre>
<pre style="background-color:#BB0000;">        0:  341:            EGS_Float L = sqrt(L_sqr);</pre>
<pre style="background-color:#BB0000;">        0:  342</pre>
<pre style="background-color:#BB0000;">        0:  343:            x = cos_t * x + sin_t * (x*z*c_phi - y*L*s_phi) / rho;</pre>
<pre style="background-color:#BB0000;">        0:  344:            y = cos_t * y + sin_t * (y*z*c_phi + x*L*s_phi) / rho;</pre>
<pre style="background-color:#BB0000;">        0:  345:            z = cos_t * z + sin_t * (-rho * c_phi);</pre>
<pre style="background-color:#BB0000;">        0:  346:        }</pre>
<pre style="background-color:#BB0000;">        0:  347:        else {</pre>
<pre style="background-color:#BB0000;">        0:  348:            x = z * sin_t * c_phi;</pre>
<pre style="background-color:#BB0000;">        0:  349:            y = z * sin_t * s_phi;</pre>
<pre style="background-color:#BB0000;">        0:  350:            z = z * cos_t;</pre>
<pre style="background-color:#BB0000;">        0:  351:        }</pre>
<pre>        -:  352:    }</pre>
<pre>        -:  353:</pre>
<pre>        -:  354:    /*! \brief</pre>
<pre>        -:  355:      Returns a string representation of the vector</pre>
<pre>        -:  356:    */</pre>
<pre style="background-color:#00BB00;">        6:  357:    string toString() const {</pre>
<pre>        -:  358</pre>
<pre style="background-color:#00BB00;">        6:  359:        EGS_Float log10x = log10(x), log10y = log10(y), log10z = log10(z);</pre>
<pre style="background-color:#00BB00;">        6:  360:        int avg_magnitude = floor((log10x+log10y+log10z) / 3.);</pre>
<pre>        -:  361:        string str = "("</pre>
<pre style="background-color:#00BB00;">       12:  362:                     + to_string(x*pow(10, -avg_magnitude)) + ", "</pre>
<pre style="background-color:#00BB00;">       24:  363:                     + to_string(y*pow(10, -avg_magnitude)) + ", "</pre>
<pre style="background-color:#00BB00;">       18:  364:                     + to_string(z*pow(10, -avg_magnitude)) + ")x10^" + to_string(avg_magnitude);</pre>
<pre style="background-color:#00BB00;">        6:  365:        return str;</pre>
<pre>        -:  366:    }</pre>
<pre>        -:  367:</pre>
<pre>        -:  368:    /*! \brief</pre>
<pre>        -:  369:      Adds a representation of the vector to the ostream</pre>
<pre>        -:  370:    */</pre>
<pre style="background-color:#00BB00;">        1:  371:    friend std:ostream &operator&lt&lt(std:ostream &os, const EGS_Vector &v) {</pre>
<pre style="background-color:#00BB00;">        1:  372:        return os &lt&lt v.toString();</pre>
<pre>        -:  373:    }</pre>
<pre>        -:  374:</pre>
<pre>        -:  375:#if __cplusplus &gt= 201703L</pre>
<pre>        -:  376:</pre>
<pre>        -:  377:    /*! \brief</pre>
<pre>        -:  378:      Sets the tolerance of the `isZero` method.</pre>
<pre>        -:  379:</pre>
<pre>        -:  380:      Returns a reference to itself so the operation can be chained.</pre>
<pre>        -:  381:    */</pre>
<pre style="background-color:#00BB00;">        2:  382:    EGS_Vector &setTolerance(EGS_Float tol) {</pre>
<pre style="background-color:#00BB00;">        2:  383:        EGS_Vector:tolerance = tol;</pre>
<pre style="background-color:#00BB00;">        2:  384:        return *this;</pre>
<pre>        -:  385:    }</pre>
<pre>        -:  386:</pre>
<pre>        -:  387:private:</pre>
<pre>        -:  388:</pre>
        -:  389:    /// The tolerance with which |v|^2 < tol is compared to qualify as a zero vector
<pre>        -:  389:    /// The tolerance with which |v|^2 &lt tol is compared to qualify as a zero vector</pre>
<pre>        -:  390:    inline static EGS_Float tolerance = 1e-10;</pre>
<pre>        -:  391:</pre>
<pre>        -:  392:#else</pre>
<pre>        -:  393:private:</pre>
<pre>        -:  394:    constexpr static EGS_Float tolarance = 1e-10;</pre>
<pre>        -:  395:#endif</pre>
<pre>        -:  396:};</pre>
<pre>        -:  397:</pre>
<pre>        -:  398:#endif</pre>

</body></html>
